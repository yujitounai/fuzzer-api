#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
脆弱性分析モジュール

3つの専用分析エンジンを提供：
1. ErrorPatternAnalyzer - エラーパターン検出
2. PayloadReflectionAnalyzer - ペイロード反射検出
3. TimeDelayAnalyzer - 時間遅延検出
"""

from typing import List, Dict, Any, Optional
from pydantic import BaseModel
from database import JobResult
from sqlalchemy.orm import Session
import statistics
import html
import urllib.parse

# Pydanticモデル定義

class ErrorPatternConfigModel(BaseModel):
    """
    エラーパターン検出の設定
    
    Attributes:
        error_patterns (Optional[List[str]]): 検出するエラーパターンのリスト
        case_sensitive (bool): 大文字小文字を区別するかどうか
    """
    error_patterns: Optional[List[str]] = None
    case_sensitive: bool = False

class ErrorPatternFinding(BaseModel):
    """
    エラーパターン検出結果
    
    Attributes:
        request_number (int): リクエスト番号
        error_pattern (str): 検出されたエラーパターン
        severity (str): 深刻度
        description (str): 詳細説明
        evidence (str): 根拠・証拠
        payload (Optional[str]): 使用されたペイロード
        response_snippet (Optional[str]): レスポンスの一部
    """
    request_number: int
    error_pattern: str
    severity: str
    description: str
    evidence: str
    payload: Optional[str] = None
    response_snippet: Optional[str] = None

class ErrorPatternAnalysisResult(BaseModel):
    """
    エラーパターン分析結果
    
    Attributes:
        job_id (str): ジョブID
        total_requests (int): 総リクエスト数
        analyzed_requests (int): 分析済みリクエスト数
        error_findings_count (int): 発見されたエラーパターンの数
        findings (List[ErrorPatternFinding]): エラーパターン検出結果のリスト
        patterns_checked (List[str]): チェックしたパターンのリスト
    """
    job_id: str
    total_requests: int
    analyzed_requests: int
    error_findings_count: int
    findings: List[ErrorPatternFinding]
    patterns_checked: List[str]

class PayloadReflectionConfigModel(BaseModel):
    """
    ペイロード反射検出の設定
    
    Attributes:
        check_html_encoding (bool): HTMLエンコーディングをチェックするかどうか
        check_url_encoding (bool): URLエンコーディングをチェックするかどうか
        check_js_encoding (bool): JavaScriptエンコーディングをチェックするかどうか
        minimum_payload_length (int): 検出対象とする最小ペイロード長
    """
    check_html_encoding: bool = True
    check_url_encoding: bool = True
    check_js_encoding: bool = True
    minimum_payload_length: int = 3

class PayloadReflectionFinding(BaseModel):
    """
    ペイロード反射検出結果
    
    Attributes:
        request_number (int): リクエスト番号
        vulnerability_type (str): 脆弱性タイプ
        severity (str): 深刻度
        description (str): 詳細説明
        evidence (str): 根拠・証拠
        payload (str): 反射されたペイロード
        response_snippet (Optional[str]): レスポンスの一部
        encoding_status (str): エンコーディング状況
    """
    request_number: int
    vulnerability_type: str
    severity: str
    description: str
    evidence: str
    payload: str
    response_snippet: Optional[str] = None
    encoding_status: str

class PayloadReflectionAnalysisResult(BaseModel):
    """
    ペイロード反射分析結果
    
    Attributes:
        job_id (str): ジョブID
        total_requests (int): 総リクエスト数
        analyzed_requests (int): 分析済みリクエスト数
        reflection_findings_count (int): 発見された反射の数
        findings (List[PayloadReflectionFinding]): 反射検出結果のリスト
        encoding_summary (Dict[str, int]): エンコーディング状況サマリー
    """
    job_id: str
    total_requests: int
    analyzed_requests: int
    reflection_findings_count: int
    findings: List[PayloadReflectionFinding]
    encoding_summary: Dict[str, int]

class TimeDelayConfigModel(BaseModel):
    """
    時間遅延検出の設定
    
    Attributes:
        time_threshold (float): 遅延として判定する閾値（秒）
        baseline_method (str): ベースライン計算方法（first_request、average、median）
        consider_payload_type (bool): ペイロードタイプを考慮するかどうか
    """
    time_threshold: float = 2.0
    baseline_method: str = "first_request"  # first_request, average, median
    consider_payload_type: bool = True

class TimeDelayFinding(BaseModel):
    """
    時間遅延検出結果
    
    Attributes:
        request_number (int): リクエスト番号
        vulnerability_type (str): 脆弱性タイプ
        severity (str): 深刻度
        description (str): 詳細説明
        evidence (str): 根拠・証拠
        payload (Optional[str]): 使用されたペイロード
        response_time (float): レスポンス時間
        baseline_time (float): ベースライン時間
        delay_amount (float): 遅延量
    """
    request_number: int
    vulnerability_type: str
    severity: str
    description: str
    evidence: str
    payload: Optional[str] = None
    response_time: float
    baseline_time: float
    delay_amount: float

class TimeDelayAnalysisResult(BaseModel):
    """
    時間遅延分析結果
    
    Attributes:
        job_id (str): ジョブID
        total_requests (int): 総リクエスト数
        analyzed_requests (int): 分析済みリクエスト数
        delay_findings_count (int): 発見された遅延の数
        findings (List[TimeDelayFinding]): 遅延検出結果のリスト
        baseline_response_time (float): ベースライン時間
        average_response_time (float): 平均レスポンス時間
        threshold_used (float): 使用した閾値
    """
    job_id: str
    total_requests: int
    analyzed_requests: int
    delay_findings_count: int
    findings: List[TimeDelayFinding]
    baseline_response_time: float
    average_response_time: float
    threshold_used: float

class ErrorPatternAnalyzer:
    """
    エラーパターン検出分析エンジン
    
    レスポンスに含まれるエラーメッセージやシステム情報を検出して、
    情報漏洩の可能性を評価します。
    """
    
    def __init__(self):
        # デフォルトのエラーパターン
        self.default_error_patterns = [
            "internal server error",
            "sql error",
            "database error",
            "mysql error",
            "postgresql",
            "oracle",
            "sqlite",
            "syntax error",
            "table doesn't exist",
            "column not found",
            "duplicate entry",
            "access denied",
            "permission denied",
            "stack trace",
            "exception",
            "error:",
            "warning:",
            "notice:",
            "fatal error",
            "parse error",
            "undefined variable",
            "undefined index",
            "undefined offset",
            "call to undefined",
            "division by zero",
            "out of memory",
            "maximum execution time",
            "connection failed",
            "timeout",
            "deadlock",
            "lock wait timeout",
            "duplicate key",
            "foreign key constraint",
            "not null constraint",
            "check constraint",
            "unique constraint",
            "primary key constraint",
            "php notice",
            "php warning",
            "php fatal error",
            "java.lang.",
            "com.mysql.",
            "org.postgresql.",
            "microsoft odbc",
            "asp.net",
            ".net framework"
        ]
    
    def analyze_job_errors(self, job_id: str, db: Session, error_patterns: Optional[List[str]] = None, case_sensitive: bool = False):
        """
        ジョブ結果のエラーパターンを分析
        
        Args:
            job_id (str): ジョブID
            db: データベースセッション
            error_patterns: チェックするエラーパターンのリスト
            case_sensitive: 大文字小文字を区別するかどうか
            
        Returns:
            ErrorPatternAnalysisResult: エラーパターン分析結果
        """
        if error_patterns is None:
            error_patterns = self.default_error_patterns
        
        # データベースから結果を取得
        db_results = db.query(JobResult).filter(
            JobResult.job_id == job_id
        ).order_by(JobResult.request_number).all()
        
        if not db_results:
            return ErrorPatternAnalysisResult(
                job_id=job_id,
                total_requests=0,
                analyzed_requests=0,
                error_findings_count=0,
                findings=[],
                patterns_checked=error_patterns
            )
        
        findings = []
        analyzed_count = 0
        
        # 各結果を分析
        for result in db_results:
            if not result.success:
                continue  # 失敗したリクエストはスキップ
                
            http_response = result.get_http_response()
            if not http_response:
                continue
                
            analyzed_count += 1
            response_body = http_response.get('body', '')
            response_headers = http_response.get('headers', {})
            
            # エラーパターンをチェック
            error_findings = self._check_error_patterns(
                result, response_body, response_headers, error_patterns, case_sensitive
            )
            findings.extend(error_findings)
        
        # 結果をPydanticモデルのfindingsリストに変換
        pydantic_findings = [ErrorPatternFinding(**finding) for finding in findings]
        
        return ErrorPatternAnalysisResult(
            job_id=job_id,
            total_requests=len(db_results),
            analyzed_requests=analyzed_count,
            error_findings_count=len(findings),
            findings=pydantic_findings,
            patterns_checked=error_patterns
        )
    
    def _check_error_patterns(self, result: JobResult, response_body: str, 
                             response_headers: Dict[str, Any], error_patterns: List[str], 
                             case_sensitive: bool = False) -> List[Dict[str, Any]]:
        """エラーパターンをチェック"""
        findings = []
        search_text = response_body if case_sensitive else response_body.lower()
        
        for pattern in error_patterns:
            search_pattern = pattern if case_sensitive else pattern.lower()
            
            if search_pattern in search_text:
                # エラーが見つかった箇所の前後を取得
                pattern_index = search_text.find(search_pattern)
                snippet_start = max(0, pattern_index - 50)
                snippet_end = min(len(response_body), pattern_index + len(pattern) + 50)
                evidence_snippet = response_body[snippet_start:snippet_end]
                
                # 深刻度を判定
                severity = self._determine_error_severity(pattern, search_text)
                
                findings.append({
                    "request_number": result.request_number,
                    "error_pattern": pattern,
                    "severity": severity,
                    "description": f"エラーメッセージまたは機密情報がレスポンスに含まれています: '{pattern}'",
                    "evidence": f"パターン '{pattern}' がレスポンスに含まれています",
                    "payload": result.payload,
                    "response_snippet": evidence_snippet
                })
        
        return findings
    
    def _determine_error_severity(self, pattern: str, response_text: str) -> str:
        """エラーの深刻度を判定"""
        pattern_lower = pattern.lower()
        
        # SQLエラーやデータベース関連は高い
        if any(keyword in pattern_lower for keyword in ['sql', 'database', 'mysql', 'postgresql', 'oracle']):
            return "high"
        
        # スタックトレースやシステム情報も高い
        if any(keyword in pattern_lower for keyword in ['stack trace', 'java.lang', 'fatal error']):
            return "high"
        
        # 一般的なエラーは中程度
        if any(keyword in pattern_lower for keyword in ['error', 'exception', 'warning']):
            return "medium"
        
        return "low"

class PayloadReflectionAnalyzer:
    """
    ペイロード反射検出分析エンジン
    
    送信したペイロードがレスポンスに反射されているかを検出し、
    XSSやインジェクション攻撃の可能性を評価します。
    """
    
    def analyze_job_reflections(self, job_id: str, db: Session, 
                               check_html_encoding: bool = True,
                               check_url_encoding: bool = True,
                               check_js_encoding: bool = True,
                               minimum_payload_length: int = 3):
        """
        ジョブ結果のペイロード反射を分析
        
        Args:
            job_id (str): ジョブID
            db: データベースセッション
            check_html_encoding: HTMLエンコーディングをチェックするかどうか
            check_url_encoding: URLエンコーディングをチェックするかどうか
            check_js_encoding: JavaScriptエンコーディングをチェックするかどうか
            minimum_payload_length: 検出対象とする最小ペイロード長
            
        Returns:
            PayloadReflectionAnalysisResult: ペイロード反射分析結果
        """
        # データベースから結果を取得
        db_results = db.query(JobResult).filter(
            JobResult.job_id == job_id
        ).order_by(JobResult.request_number).all()
        
        if not db_results:
            return PayloadReflectionAnalysisResult(
                job_id=job_id,
                total_requests=0,
                analyzed_requests=0,
                reflection_findings_count=0,
                findings=[],
                encoding_summary={}
            )
        
        findings = []
        analyzed_count = 0
        encoding_stats = {"encoded": 0, "not_encoded": 0, "partial": 0}
        
        # 各結果を分析
        for result in db_results:
            if not result.success or not result.payload:
                continue  # 失敗したリクエストやペイロードなしはスキップ
                
            if len(result.payload) < minimum_payload_length:
                continue  # 短すぎるペイロードはスキップ
                
            http_response = result.get_http_response()
            if not http_response:
                continue
                
            analyzed_count += 1
            response_body = http_response.get('body', '')
            response_headers = http_response.get('headers', {})
            
            # ペイロード反射をチェック
            reflection_findings = self._check_payload_reflection(
                result, response_body, response_headers,
                check_html_encoding, check_url_encoding, check_js_encoding
            )
            
            if reflection_findings:
                findings.extend(reflection_findings)
                # エンコーディング統計を更新
                for finding in reflection_findings:
                    encoding_status = finding.get("encoding_status", "unknown")
                    if encoding_status in encoding_stats:
                        encoding_stats[encoding_status] += 1
        
        # 結果をPydanticモデルのfindingsリストに変換
        pydantic_findings = [PayloadReflectionFinding(**finding) for finding in findings]
        
        return PayloadReflectionAnalysisResult(
            job_id=job_id,
            total_requests=len(db_results),
            analyzed_requests=analyzed_count,
            reflection_findings_count=len(findings),
            findings=pydantic_findings,
            encoding_summary=encoding_stats
        )
    
    def _check_payload_reflection(self, result: JobResult, response_body: str, 
                                 response_headers: Dict[str, Any], 
                                 check_html_encoding: bool = True,
                                 check_url_encoding: bool = True,
                                 check_js_encoding: bool = True) -> List[Dict[str, Any]]:
        """ペイロード反射をチェック"""
        findings = []
        payload = result.payload
        
        if not payload:
            return findings
        
        # レスポンスボディにペイロードが含まれているかチェック
        if payload in response_body:
            encoding_status = "not_encoded"
            vulnerability_type = "Input Reflection"
            severity = "medium"
            
            # 各種エンコーディングをチェック
            if check_html_encoding:
                html_escaped = html.escape(payload)
                if html_escaped in response_body:
                    encoding_status = "encoded"
                elif payload in response_body:
                    # HTMLエスケープされていない
                    if any(char in payload for char in ['<', '>', '"', "'"]):
                        vulnerability_type = "Cross-Site Scripting (XSS)"
                        severity = self._determine_reflection_severity(payload)
            
            if check_url_encoding:
                url_encoded = urllib.parse.quote(payload)
                if url_encoded in response_body and payload in response_body:
                    encoding_status = "partial"
            
            # ペイロードが見つかった箇所の前後を取得
            payload_index = response_body.find(payload)
            snippet_start = max(0, payload_index - 50)
            snippet_end = min(len(response_body), payload_index + len(payload) + 50)
            evidence_snippet = response_body[snippet_start:snippet_end]
            
            findings.append({
                "request_number": result.request_number,
                "vulnerability_type": vulnerability_type,
                "severity": severity,
                "description": f"ペイロードがレスポンスに反射されています",
                "evidence": f"ペイロード '{payload}' がレスポンスに含まれています",
                "payload": payload,
                "response_snippet": evidence_snippet,
                "encoding_status": encoding_status
            })
        
        return findings
    
    def _determine_reflection_severity(self, payload: str) -> str:
        """反射の深刻度を判定"""
        payload_lower = payload.lower()
        
        # JavaScriptやスクリプトタグは高い
        if any(keyword in payload_lower for keyword in ['<script>', 'javascript:', 'vbscript:', 'onload=', 'onerror=']):
            return "high"
        
        # HTML特殊文字を含む入力は中程度
        if any(char in payload for char in ['<', '>', '"', "'"]):
            return "medium"
        
        return "low"

class TimeDelayAnalyzer:
    """
    時間遅延検出分析エンジン
    
    リクエストのレスポンス時間を分析して、
    時間ベースのSQLインジェクションやDoS攻撃の可能性を評価します。
    """
    
    def analyze_job_time_delays(self, job_id: str, db: Session,
                               time_threshold: float = 2.0,
                               baseline_method: str = "first_request",
                               consider_payload_type: bool = True):
        """
        ジョブ結果の時間遅延を分析
        
        Args:
            job_id (str): ジョブID
            db: データベースセッション
            time_threshold: 遅延として判定する閾値（秒）
            baseline_method: ベースライン計算方法
            consider_payload_type: ペイロードタイプを考慮するかどうか
            
        Returns:
            TimeDelayAnalysisResult: 時間遅延分析結果
        """
        # データベースから結果を取得
        db_results = db.query(JobResult).filter(
            JobResult.job_id == job_id
        ).order_by(JobResult.request_number).all()
        
        if not db_results:
            return TimeDelayAnalysisResult(
                job_id=job_id,
                total_requests=0,
                analyzed_requests=0,
                delay_findings_count=0,
                findings=[],
                baseline_response_time=0.0,
                average_response_time=0.0,
                threshold_used=time_threshold
            )
        
        # レスポンス時間を収集
        response_times = []
        valid_results = []
        
        for result in db_results:
            if not result.success:
                continue
                
            http_response = result.get_http_response()
            if not http_response or 'elapsed_time' not in http_response:
                continue
                
            response_times.append(http_response['elapsed_time'])
            valid_results.append(result)
        
        if not response_times:
            return TimeDelayAnalysisResult(
                job_id=job_id,
                total_requests=len(db_results),
                analyzed_requests=0,
                delay_findings_count=0,
                findings=[],
                baseline_response_time=0.0,
                average_response_time=0.0,
                threshold_used=time_threshold
            )
        
        # ベースライン時間を計算
        baseline_time = self._calculate_baseline(response_times, baseline_method)
        average_time = statistics.mean(response_times)
        
        # 遅延をチェック
        findings = []
        for result, elapsed_time in zip(valid_results, response_times):
            delay_findings = self._check_time_delay(
                result, elapsed_time, baseline_time, time_threshold, consider_payload_type
            )
            findings.extend(delay_findings)
        
        # 結果をPydanticモデルのfindingsリストに変換
        pydantic_findings = [TimeDelayFinding(**finding) for finding in findings]
        
        return TimeDelayAnalysisResult(
            job_id=job_id,
            total_requests=len(db_results),
            analyzed_requests=len(valid_results),
            delay_findings_count=len(findings),
            findings=pydantic_findings,
            baseline_response_time=baseline_time,
            average_response_time=average_time,
            threshold_used=time_threshold
        )
    
    def _calculate_baseline(self, response_times: List[float], method: str) -> float:
        """ベースライン時間を計算"""
        if method == "first_request":
            return response_times[0] if response_times else 0.0
        elif method == "average":
            return statistics.mean(response_times)
        elif method == "median":
            return statistics.median(response_times)
        else:
            return response_times[0] if response_times else 0.0
    
    def _check_time_delay(self, result: JobResult, elapsed_time: float, 
                         baseline_time: float, threshold: float, 
                         consider_payload_type: bool = True) -> List[Dict[str, Any]]:
        """時間遅延をチェック"""
        findings = []
        
        if elapsed_time > baseline_time + threshold:
            delay = elapsed_time - baseline_time
            
            # ペイロードタイプを考慮した分析
            vulnerability_type = "Performance Anomaly"
            severity = "medium"
            description = "レスポンス時間に異常な遅延が検出されました"
            
            if consider_payload_type and result.payload:
                payload_lower = result.payload.lower()
                
                # SQLインジェクション関連キーワード
                if any(keyword in payload_lower for keyword in ['sleep', 'waitfor', 'delay', 'benchmark', 'pg_sleep']):
                    vulnerability_type = "SQL Injection (Time-based)"
                    severity = "high"
                    description = "時間ベースのSQLインジェクションの可能性があります"
                
                # その他の遅延関連キーワード
                elif any(keyword in payload_lower for keyword in ['timeout', 'hang', 'freeze']):
                    vulnerability_type = "Denial of Service"
                    severity = "high"
                    description = "DoS攻撃の可能性があります"
            
            findings.append({
                "request_number": result.request_number,
                "vulnerability_type": vulnerability_type,
                "severity": severity,
                "description": description,
                "evidence": f"ベースライン: {baseline_time:.3f}秒, 実測値: {elapsed_time:.3f}秒, 遅延: {delay:.3f}秒",
                "payload": result.payload,
                "response_time": elapsed_time,
                "baseline_time": baseline_time,
                "delay_amount": delay
            })
        
        return findings

# グローバルインスタンス
error_pattern_analyzer = ErrorPatternAnalyzer()
payload_reflection_analyzer = PayloadReflectionAnalyzer()
time_delay_analyzer = TimeDelayAnalyzer() 