#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
分離された脆弱性分析API テストスクリプト

新しく分離された3つの脆弱性分析APIエンドポイントをテストします：
1. エラーパターン検出API
2. ペイロード反射検出API  
3. 時間遅延検出API

使用方法:
    python test_separated_vulnerability_apis.py

機能:
    - 認証とジョブ実行
    - 包括的な攻撃ペイロードテスト
    - 3つの分析APIの詳細テスト
    - エラーハンドリングテスト
    - 結果の詳細分析と表示
"""

import requests
import time
import json
from typing import Optional, Dict, Any

# 設定
BASE_URL = "http://localhost:8000"
LOGIN_URL = f"{BASE_URL}/api/auth/login"
USERNAME = "admin"
PASSWORD = "admin123"

def login():
    """
    APIにログインしてトークンを取得
    
    Returns:
        str: アクセストークン
    """
    login_data = {
        "username": USERNAME,
        "password": PASSWORD
    }
    
    response = requests.post(LOGIN_URL, json=login_data)
    if response.status_code == 200:
        token_data = response.json()
        return token_data["access_token"]
    else:
        print(f"ログインエラー: {response.status_code} - {response.text}")
        return None

def create_comprehensive_test_requests(token):
    """
    包括的なテスト用のリクエストを生成
    
    Args:
        token: 認証トークン
        
    Returns:
        int: リクエストID
    """
    headers = {"Authorization": f"Bearer {token}"}
    
    # より包括的な攻撃ペイロードセット
    request_data = {
        "template": "GET /get?q=<<X>>&type=<<Y>> HTTP/1.1\\r\\nHost: target.com\\r\\n\\r\\n",
        "placeholders": ["X", "Y"],
        "strategy": "cluster_bomb",
        "payload_sets": [
            {
                "name": "comprehensive_attacks",
                "payloads": [
                    # SQLインジェクション
                    "'",
                    "1' OR '1'='1",
                    "'; DROP TABLE users; --",
                    "1'; WAITFOR DELAY '00:00:03'--",
                    "1' AND (SELECT COUNT(*) FROM sysobjects)>0--",
                    
                    # XSS攻撃
                    "<script>alert('XSS')</script>",
                    "<img src=x onerror=alert('XSS2')>",
                    "javascript:alert('XSS3')",
                    "<svg onload=alert('XSS4')>",
                    "'\"><script>alert('XSS5')</script>",
                    
                    # テンプレートインジェクション
                    "{{7*7}}",
                    "${7*7}",
                    "#{7*7}",
                    
                    # パストラバーサル
                    "../../../../etc/passwd",
                    "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                    
                    # コマンドインジェクション
                    "; ls -la",
                    "| whoami",
                    "& ipconfig",
                    
                    # 通常のクエリ（比較用）
                    "normal_query",
                    "test_search"
                ]
            },
            {
                "name": "search_types",
                "payloads": [
                    "user",
                    "admin", 
                    "product",
                    "system",
                    "config"
                ]
            }
        ]
    }
    
    response = requests.post(
        f"{BASE_URL}/api/replace-placeholders",
        json=request_data,
        headers=headers
    )
    
    if response.status_code == 200:
        result = response.json()
        print(f"✅ リクエスト生成成功: ID={result['request_id']}, 総数={result['total_requests']}")
        return result["request_id"]
    else:
        print(f"リクエスト生成エラー: {response.status_code} - {response.text}")
        return None

def execute_requests_with_delay(request_id, token):
    """
    生成されたリクエストを実行（時間遅延検出のため意図的に遅延を追加）
    
    Args:
        request_id: リクエストID
        token: 認証トークン
        
    Returns:
        str: ジョブID
    """
    headers = {"Authorization": f"Bearer {token}"}
    
    execute_data = {
        "request_id": request_id,
        "http_config": {
            "timeout": 30,
            "follow_redirects": True,
            "verify_ssl": False,
            "scheme": "http",
            "base_url": "httpbin.org",
            "sequential_execution": True,
            "request_delay": 0.5  # 意図的な遅延で時間遅延分析をテスト
        }
    }
    
    response = requests.post(
        f"{BASE_URL}/api/execute-requests",
        json=execute_data,
        headers=headers
    )
    
    if response.status_code == 200:
        job_data = response.json()
        job_id = job_data["job_id"]
        print(f"✅ ジョブ開始: {job_id}")
        return job_id
    else:
        print(f"実行エラー: {response.status_code} - {response.text}")
        return None

def wait_for_job_completion(job_id, token, max_wait_time=180):
    """
    ジョブの完了を待機
    
    Args:
        job_id: ジョブID
        token: 認証トークン
        max_wait_time: 最大待機時間（秒）
        
    Returns:
        bool: 完了したかどうか
    """
    headers = {"Authorization": f"Bearer {token}"}
    start_time = time.time()
    last_progress = 0
    
    while time.time() - start_time < max_wait_time:
        response = requests.get(
            f"{BASE_URL}/api/jobs/{job_id}",
            headers=headers
        )
        
        if response.status_code == 200:
            job_data = response.json()
            status = job_data["status"]
            progress = job_data.get("progress", {})
            
            # 進捗表示の改善
            current_progress = progress.get("progress_percentage", 0)
            if current_progress != last_progress:
                print(f"進捗: {current_progress:.1f}% ({progress.get('completed_requests', 0)}/{progress.get('total_requests', 0)})")
                last_progress = current_progress
            
            if status == "completed":
                print("✅ ジョブ完了")
                return True
            elif status == "failed":
                print(f"❌ ジョブ失敗: {job_data.get('error_message', 'Unknown error')}")
                return False
        
        time.sleep(0.5)
    
    print("❌ ジョブ完了待機がタイムアウトしました")
    return False

def test_error_pattern_analysis(job_id, token):
    """
    エラーパターン分析APIのテスト
    
    Args:
        job_id: ジョブID
        token: 認証トークン
    """
    print("\\n" + "="*50)
    print("🔍 エラーパターン分析テスト")
    print("="*50)
    headers = {"Authorization": f"Bearer {token}"}
    
    # POSTメソッドでのテスト（デフォルト設定）
    print("\\n1. POST分析（デフォルト設定）:")
    response = requests.post(
        f"{BASE_URL}/api/jobs/{job_id}/analyze/error-patterns",
        headers=headers
    )
    
    if response.status_code == 200:
        result = response.json()
        print(f"✅ 分析成功:")
        print(f"  📊 総リクエスト数: {result['total_requests']}")
        print(f"  📊 分析済み数: {result['analyzed_requests']}")
        print(f"  📊 エラー検出数: {result['error_findings_count']}")
        print(f"  📊 チェックパターン数: {len(result['patterns_checked'])}")
        
        if result['findings']:
            print(f"\\n🚨 検出されたエラーパターン (最初の5件):")
            for i, finding in enumerate(result['findings'][:5], 1):
                print(f"  {i}. リクエスト{finding['request_number']}: {finding['error_pattern']}")
                print(f"     深刻度: {finding['severity']}")
                print(f"     ペイロード: {finding.get('payload', 'N/A')}")
                if finding.get('response_snippet'):
                    snippet = finding['response_snippet'][:100] + "..." if len(finding['response_snippet']) > 100 else finding['response_snippet']
                    print(f"     証拠: {snippet}")
                print()
        else:
            print("  ℹ️ エラーパターンは検出されませんでした（正常）")
    else:
        print(f"❌ エラーパターン分析エラー: {response.status_code} - {response.text}")
    
    # POSTメソッドでのテスト（カスタム設定）
    print("\\n2. POST分析（カスタム設定 - 高精度）:")
    custom_config = {
        "error_patterns": [
            "sql error", "database error", "mysql", "postgresql", "oracle",
            "stack trace", "exception", "internal server error",
            "access denied", "permission denied", "401", "403", "500"
        ],
        "case_sensitive": False
    }
    
    response = requests.post(
        f"{BASE_URL}/api/jobs/{job_id}/analyze/error-patterns",
        headers=headers,
        json=custom_config
    )
    
    if response.status_code == 200:
        result = response.json()
        print(f"✅ カスタム設定での検出数: {result['error_findings_count']}")
        if result['error_findings_count'] > 0:
            print("  🎯 カスタムパターンで追加検出あり")
    else:
        print(f"❌ カスタム設定エラー: {response.status_code}")
    
    # GETメソッドでのテスト
    print("\\n3. GET分析（クエリパラメータ）:")
    patterns_query = "sql error,database error,exception,stack trace"
    response = requests.get(
        f"{BASE_URL}/api/jobs/{job_id}/analyze/error-patterns?error_patterns={patterns_query}&case_sensitive=false",
        headers=headers
    )
    
    if response.status_code == 200:
        result = response.json()
        print(f"✅ GETメソッドでの検出数: {result['error_findings_count']}")
    else:
        print(f"❌ GETエラーパターン分析エラー: {response.status_code}")

def test_payload_reflection_analysis(job_id, token):
    """
    ペイロード反射分析APIのテスト
    
    Args:
        job_id: ジョブID
        token: 認証トークン
    """
    print("\\n" + "="*50)
    print("🔄 ペイロード反射分析テスト")
    print("="*50)
    headers = {"Authorization": f"Bearer {token}"}
    
    # POSTメソッドでのテスト（デフォルト設定）
    print("\\n1. POST分析（デフォルト設定）:")
    response = requests.post(
        f"{BASE_URL}/api/jobs/{job_id}/analyze/payload-reflection",
        headers=headers
    )
    
    if response.status_code == 200:
        result = response.json()
        print(f"✅ 分析成功:")
        print(f"  📊 総リクエスト数: {result['total_requests']}")
        print(f"  📊 分析済み数: {result['analyzed_requests']}")
        print(f"  📊 反射検出数: {result['reflection_findings_count']}")
        
        # エンコーディング統計の詳細表示
        encoding_summary = result['encoding_summary']
        total_checked = sum(encoding_summary.values())
        if total_checked > 0:
            print(f"\\n📈 エンコーディング統計:")
            print(f"  🔒 適切にエンコード済み: {encoding_summary['encoded']} ({encoding_summary['encoded']/total_checked*100:.1f}%)")
            print(f"  ⚠️ エンコードなし: {encoding_summary['not_encoded']} ({encoding_summary['not_encoded']/total_checked*100:.1f}%)")
            print(f"  🔶 部分エンコード: {encoding_summary['partial']} ({encoding_summary['partial']/total_checked*100:.1f}%)")
        
        if result['findings']:
            print(f"\\n🚨 検出されたペイロード反射 (最初の5件):")
            for i, finding in enumerate(result['findings'][:5], 1):
                print(f"  {i}. リクエスト{finding['request_number']}: {finding['vulnerability_type']}")
                print(f"     深刻度: {finding['severity']}")
                print(f"     ペイロード: {finding['payload']}")
                print(f"     エンコーディング状況: {finding['encoding_status']}")
                if finding.get('response_snippet'):
                    snippet = finding['response_snippet'][:100] + "..." if len(finding['response_snippet']) > 100 else finding['response_snippet']
                    print(f"     証拠: {snippet}")
                print()
        else:
            print("  ℹ️ 危険な反射は検出されませんでした（正常）")
    else:
        print(f"❌ ペイロード反射分析エラー: {response.status_code} - {response.text}")
    
    # POSTメソッドでのテスト（高精度設定）
    print("\\n2. POST分析（高精度設定）:")
    high_precision_config = {
        "check_html_encoding": True,
        "check_url_encoding": True,
        "check_js_encoding": True,
        "minimum_payload_length": 2  # より短いペイロードも検出
    }
    
    response = requests.post(
        f"{BASE_URL}/api/jobs/{job_id}/analyze/payload-reflection",
        headers=headers,
        json=high_precision_config
    )
    
    if response.status_code == 200:
        result = response.json()
        print(f"✅ 高精度設定での検出数: {result['reflection_findings_count']}")
    else:
        print(f"❌ 高精度設定エラー: {response.status_code}")
    
    # GETメソッドでのテスト
    print("\\n3. GET分析（HTMLエンコーディング専用）:")
    response = requests.get(
        f"{BASE_URL}/api/jobs/{job_id}/analyze/payload-reflection?check_html_encoding=true&check_url_encoding=false&minimum_payload_length=3",
        headers=headers
    )
    
    if response.status_code == 200:
        result = response.json()
        print(f"✅ HTMLエンコーディング専用検出数: {result['reflection_findings_count']}")
    else:
        print(f"❌ GETペイロード反射分析エラー: {response.status_code}")

def test_time_delay_analysis(job_id, token):
    """
    時間遅延分析APIのテスト
    
    Args:
        job_id: ジョブID
        token: 認証トークン
    """
    print("\\n" + "="*50)
    print("⏱️ 時間遅延分析テスト")
    print("="*50)
    headers = {"Authorization": f"Bearer {token}"}
    
    # POSTメソッドでのテスト（低い閾値設定）
    print("\\n1. POST分析（低い閾値設定）:")
    low_threshold_config = {
        "time_threshold": 1.0,  # 1秒閾値でより多くの遅延を検出
        "baseline_method": "first_request",
        "consider_payload_type": True
    }
    
    response = requests.post(
        f"{BASE_URL}/api/jobs/{job_id}/analyze/time-delay",
        headers=headers,
        json=low_threshold_config
    )
    
    if response.status_code == 200:
        result = response.json()
        print(f"✅ 分析成功:")
        print(f"  📊 総リクエスト数: {result['total_requests']}")
        print(f"  📊 分析済み数: {result['analyzed_requests']}")
        print(f"  📊 遅延検出数: {result['delay_findings_count']}")
        print(f"  📊 ベースライン時間: {result['baseline_response_time']:.3f}秒")
        print(f"  📊 平均レスポンス時間: {result['average_response_time']:.3f}秒")
        print(f"  📊 使用閾値: {result['threshold_used']:.1f}秒")
        
        if result['findings']:
            print(f"\\n🚨 検出された時間遅延 (最初の3件):")
            for i, finding in enumerate(result['findings'][:3], 1):
                print(f"  {i}. リクエスト{finding['request_number']}: {finding['vulnerability_type']}")
                print(f"     深刻度: {finding['severity']}")
                print(f"     ペイロード: {finding.get('payload', 'N/A')}")
                print(f"     レスポンス時間: {finding['response_time']:.3f}秒")
                print(f"     ベースライン: {finding['baseline_time']:.3f}秒")
                print(f"     遅延量: {finding['delay_amount']:.3f}秒")
                print()
        else:
            print("  ℹ️ 有意な時間遅延は検出されませんでした")
    else:
        print(f"❌ 時間遅延分析エラー: {response.status_code} - {response.text}")
    
    # POSTメソッドでのテスト（高い閾値設定）
    print("\\n2. POST分析（高い閾値設定）:")
    high_threshold_config = {
        "time_threshold": 3.0,  # 3秒閾値で重要な遅延のみ
        "baseline_method": "average",
        "consider_payload_type": True
    }
    
    response = requests.post(
        f"{BASE_URL}/api/jobs/{job_id}/analyze/time-delay",
        headers=headers,
        json=high_threshold_config
    )
    
    if response.status_code == 200:
        result = response.json()
        print(f"✅ 高閾値設定での検出数: {result['delay_findings_count']}")
        if result['delay_findings_count'] > 0:
            print("  ⚠️ 重大な遅延が検出されました")
    else:
        print(f"❌ 高閾値設定エラー: {response.status_code}")
    
    # GETメソッドでのテスト（中央値ベースライン）
    print("\\n3. GET分析（中央値ベースライン）:")
    response = requests.get(
        f"{BASE_URL}/api/jobs/{job_id}/analyze/time-delay?time_threshold=2.0&baseline_method=median&consider_payload_type=false",
        headers=headers
    )
    
    if response.status_code == 200:
        result = response.json()
        print(f"✅ 中央値ベースラインでの検出数: {result['delay_findings_count']}")
        print(f"  📊 ベースライン時間: {result['baseline_response_time']:.3f}秒")
    else:
        print(f"❌ GET時間遅延分析エラー: {response.status_code}")

def test_error_cases(job_id, token):
    """
    エラーケースのテスト
    
    Args:
        job_id: ジョブID
        token: 認証トークン
    """
    print("\\n" + "="*50)
    print("🧪 エラーケーステスト")
    print("="*50)
    headers = {"Authorization": f"Bearer {token}"}
    
    # 存在しないジョブIDでのテスト
    print("\\n1. 存在しないジョブIDテスト:")
    fake_job_id = "nonexistent-job-12345"
    response = requests.post(
        f"{BASE_URL}/api/jobs/{fake_job_id}/analyze/error-patterns",
        headers=headers
    )
    
    if response.status_code == 404:
        print("✅ 存在しないジョブIDのエラーハンドリング: 正常")
    else:
        print(f"❌ 期待されるエラーコード 404, 実際: {response.status_code}")
    
    # 不正な設定でのテスト
    print("\\n2. 不正な設定テスト:")
    invalid_config = {
        "time_threshold": -1,  # 不正な閾値
        "baseline_method": "invalid_method"  # 不正なメソッド
    }
    
    response = requests.post(
        f"{BASE_URL}/api/jobs/{job_id}/analyze/time-delay",
        headers=headers,
        json=invalid_config
    )
    
    if response.status_code in [400, 422]:
        print("✅ 不正な設定のエラーハンドリング: 正常")
    else:
        print(f"❌ 期待されるエラーコード 400/422, 実際: {response.status_code}")
    
    # 認証なしでのテスト
    print("\\n3. 認証なしアクセステスト:")
    response = requests.post(
        f"{BASE_URL}/api/jobs/{job_id}/analyze/error-patterns"
    )
    
    if response.status_code == 401:
        print("✅ 認証なしアクセスのエラーハンドリング: 正常")
    else:
        print(f"❌ 期待されるエラーコード 401, 実際: {response.status_code}")

def print_comprehensive_summary(results):
    """
    包括的な結果サマリーを表示
    
    Args:
        results: テスト結果辞書
    """
    print("\\n" + "="*60)
    print("📊 包括的テスト結果サマリー")
    print("="*60)
    
    print(f"🔍 エラーパターン分析:")
    print(f"  デフォルト設定: {'✅' if results.get('error_default') else '❌'}")
    print(f"  カスタム設定: {'✅' if results.get('error_custom') else '❌'}")
    print(f"  GETメソッド: {'✅' if results.get('error_get') else '❌'}")
    
    print(f"\\n🔄 ペイロード反射分析:")
    print(f"  デフォルト設定: {'✅' if results.get('reflection_default') else '❌'}")
    print(f"  高精度設定: {'✅' if results.get('reflection_precision') else '❌'}")
    print(f"  GETメソッド: {'✅' if results.get('reflection_get') else '❌'}")
    
    print(f"\\n⏱️ 時間遅延分析:")
    print(f"  低閾値設定: {'✅' if results.get('delay_low') else '❌'}")
    print(f"  高閾値設定: {'✅' if results.get('delay_high') else '❌'}")
    print(f"  GETメソッド: {'✅' if results.get('delay_get') else '❌'}")
    
    print(f"\\n🧪 エラーハンドリング:")
    print(f"  不正ジョブID: {'✅' if results.get('error_404') else '❌'}")
    print(f"  不正設定: {'✅' if results.get('error_config') else '❌'}")
    print(f"  認証なし: {'✅' if results.get('error_auth') else '❌'}")
    
    # 成功率計算
    total_tests = len([k for k in results.keys() if k.startswith(('error_', 'reflection_', 'delay_'))])
    passed_tests = len([k for k, v in results.items() if v and k.startswith(('error_', 'reflection_', 'delay_'))])
    
    if total_tests > 0:
        success_rate = (passed_tests / total_tests) * 100
        print(f"\\n📈 総合成功率: {success_rate:.1f}% ({passed_tests}/{total_tests})")
        
        if success_rate >= 90:
            print("🎉 優秀！ほぼ全てのテストに成功しました")
        elif success_rate >= 70:
            print("👍 良好です。大部分のテストに成功しました")
        else:
            print("⚠️ いくつかの問題があります。ログを確認してください")

def main():
    """
    メイン実行関数
    """
    print("="*60)
    print("🚀 分離された脆弱性分析API 包括テスト開始")
    print("="*60)
    
    results = {}
    
    # 1. ログイン
    print("\\n1. ログイン中...")
    token = login()
    if not token:
        print("❌ ログインに失敗しました")
        return
    print("✅ ログイン成功")
    
    # 2. テストリクエスト生成
    print("\\n2. 包括的テストリクエスト生成中...")
    request_id = create_comprehensive_test_requests(token)
    if not request_id:
        print("❌ リクエスト生成に失敗しました")
        return
    
    # 3. リクエスト実行
    print("\\n3. リクエスト実行中...")
    job_id = execute_requests_with_delay(request_id, token)
    if not job_id:
        print("❌ ジョブ実行に失敗しました")
        return
    
    # 4. ジョブ完了待機
    print("\\n4. ジョブ完了待機中...")
    if not wait_for_job_completion(job_id, token):
        print("❌ ジョブが完了しませんでした")
        return
    
    # 5. 脆弱性分析テスト実行
    try:
        test_error_pattern_analysis(job_id, token)
        test_payload_reflection_analysis(job_id, token)
        test_time_delay_analysis(job_id, token)
        test_error_cases(job_id, token)
        
        print("\\n" + "="*60)
        print("🏁 全ての分析APIテスト完了")
        print("="*60)
        
    except Exception as e:
        print(f"❌ テスト実行中にエラーが発生しました: {e}")

if __name__ == "__main__":
    main() 